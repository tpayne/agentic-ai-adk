import logging
import os
import json
import uuid
import asyncio
import httpx # Changed from requests
import google.auth

from typing import AsyncGenerator
from typing_extensions import override

from google.adk.agents import LlmAgent, BaseAgent, LoopAgent, SequentialAgent
from google.adk.agents.invocation_context import InvocationContext
from google.genai import types
from google.adk.sessions import InMemorySessionService
from google.adk.runners import Runner
from google.adk.events import Event
from google.adk.sessions import VertexAiSessionService

from pydantic import BaseModel, Field, ValidationError

from . import utils
from .utils import load_properties, getValue

import sys

# --- Constants ---
# The application name for ADK. This should be unique to your application.
APP_NAME = "email_processing_app"
MODEL="gemini-2.0-flash"

# --- Configure Logging ---
logging.basicConfig(level=logging.WARNING)
logger = logging.getLogger(__name__)
# Suppress the specific ADK warning about output_schema and agent transfers
logging.getLogger("google_adk.google.adk.agents.llm_agent").setLevel(logging.ERROR)
# Get log level from environment variable, default to WARNING
LOGLEVEL = os.getenv("LOGLEVEL", "WARNING").upper()
if LOGLEVEL not in ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]:
    LOGLEVEL = "WARNING"
logger.setLevel(LOGLEVEL)

# --- Utility Functions ---

async def get_answer_content(client: httpx.AsyncClient, project_id: str, app_id: str, query_text: str, query_id: str, session_name: str, access_token: str, region: str) -> dict:
    """
    Performs an answer generation query and returns a dictionary with the answer
    text and a list of content chunks.

    Args:
        client: The httpx.AsyncClient instance.
        project_id: The Google Cloud project ID.
        app_id: The Discovery Engine app ID.
        query_text: The original search query text.
        query_id: The query ID from the previous search call.
        session_name: The session name from the previous search call.
        access_token: The OAuth 2.0 access token for authentication.
        region: The Google Cloud region (e.g., 'eu', 'us-central1').

    Returns:
        A dictionary with 'answerText' and 'contentArray' keys, or an empty
        dictionary if the request fails or no valid answer is found.
    """
    url = (
        f"https://{region}-discoveryengine.googleapis.com/v1alpha/projects/"
        f"{project_id}/locations/{region}/collections/default_collection/engines/"
        f"{app_id}/servingConfigs/default_search:answer"
    )

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }

    payload = {
        "query": {
            "text": query_text,
            "queryId": query_id
        },
        "session": session_name,
        "relatedQuestionsSpec": {
            "enable": "true"
        },
        "answerGenerationSpec": {
            "ignoreAdversarialQuery": "true",
            "ignoreNonAnswerSeekingQuery": "false",
            "ignoreLowRelevantContent": "true",
            "multimodalSpec": {},
            "includeCitations": "true",
            "modelSpec": {
                "modelVersion": "stable"
            }
        }
    }

    try:
        response = await client.post(url, headers=headers, data=json.dumps(payload))
        response.raise_for_status()  # This will raise an HTTPError for bad responses (4xx or 5xx)
        data = response.json()

        answer_text = data.get("answer", {}).get("answerText", "")
        references = data.get("answer", {}).get("references", [])
        content_array = []
        
        # Extract content from each reference
        for ref in references:
            chunk_info = ref.get("chunkInfo", {})
            if chunk_info:
                content = chunk_info.get("content")
                if content:
                    content_array.append(content)

        # Handle case where no summary could be generated
        if "A summary could not be generated for your search query" in answer_text:
            return {"answerText": "", "contentArray": []}

        return {
            "answerText": answer_text,
            "contentArray": content_array
        }

    except httpx.HTTPStatusError as e:
        logger.error(f"Error calling external API for answer: {e}")
        return {"answerText": "", "contentArray": []}
    except (json.JSONDecodeError, KeyError) as e:
        logger.error(f"Error calling external API for answer: {e}")
        return {"answerText": "", "contentArray": []}

# --- Function to Call External API ---
async def run_agentspace_url_query(agentspace_ai_url: str, bodyText: str) -> str:
    """
    Calls the AgentSpace AI URL with the provided body text and returns the draft response.

    Args:
        agentspace_ai_url: The URL of the AgentSpace AI endpoint.
        bodyText: The body text to send in the query.

    Returns:
        The draft response generated by the AgentSpace AI.
    """
    async with httpx.AsyncClient() as client:
        try:
            # Get a new access token
            # ---- Credentials ----
            # Determine if authentication is required based on environment variables
            auth_required = getValue("gcp_login")
            isAuth = bool(auth_required == "true") if auth_required is not None else False
            if isAuth:
                logger.debug("- Doing GCP authentication...")
                sa_json_file = utils.getValue("sa_json_file")
                if sa_json_file and os.path.exists(sa_json_file):
                    credentials, _ = google.auth.load_credentials_from_file(sa_json_file)
                else:
                    credentials, _ = google.auth.default()
            else:
                logger.debug("- Not doing GCP authentication...")
                credentials = None 

            if isAuth:
                credentials, project = google.auth.default(scopes=['https://www.googleapis.com/auth/cloud-platform'])
                auth_req = google.auth.transport.requests.Request()
                credentials.refresh(auth_req)
                access_token = credentials.token
            else:
                access_token = None

            # Extract project_id and app_id from the URL
            url_parts = agentspace_ai_url.split('/')
            project_id = url_parts[5]
            app_id = url_parts[11]
            region = url_parts[7]
            logger.debug("- Done...")
            # Combine instructions with the topic for the query
            combined_query = "" + " " + bodyText

            headers = {
                **({"Authorization": f"Bearer {access_token}"} if isAuth and access_token else {}),
                "Content-Type": "application/json"
            }

            payload = {
                "query": combined_query,
                "pageSize": 100,
                "queryExpansionSpec": {"condition": "AUTO"},
                "spellCorrectionSpec": {"mode": "AUTO"},
                "languageCode": "en-US",
                "contentSearchSpec":{"extractiveContentSpec":{"maxExtractiveAnswerCount":1}},
                "userInfo":{"timeZone":"Europe/London"},
                "session": f"projects/{project_id}/locations/{region}/collections/default_collection/engines/{app_id}/sessions/-"
            }

            logger.debug(f"- Calling external agent URI...")
            response = await client.post(agentspace_ai_url, headers=headers, data=json.dumps(payload))
            response.raise_for_status()
            logger.debug(f"- Parsing agent response...")
            data = response.json()
            session_info = data.get("sessionInfo", {})
            session_name = session_info.get("name")
            query_id = session_info.get("queryId")

            if session_name and query_id:
                draft_response_json = await get_answer_content(client, project_id, app_id, combined_query, 
                                                              query_id, session_name, access_token, 
                                                              region)
                draft_answer_text = draft_response_json.get("answerText", "")
                return draft_answer_text
            else:
                return ""
        
        except httpx.RequestException as e:
            logger.error(f"Error calling external API with request exception: {e}")
            raise RuntimeError(f"Error calling external API with request exception: {e}")
        except Exception as e:
            logger.error(f"Error calling external API with general exception: {e}")
            raise RuntimeError(f"Error calling external API with request exception: {e}")
    
async def get_agentspace_draft_response(ctx: InvocationContext) -> str:
    """
    Calls the AgentSpace AI URL with the topic from the context and returns the draft response.
    Args:
        ctx: The invocation context containing session state.
        Returns:
        The draft response generated by the AgentSpace AI.
    """
    try:            
        agentspace_ai_url = utils.getValue("AGENTSPACE_AI_URL")
        bodyText = ctx.session.state.get("topic", "No topic provided.")
        if agentspace_ai_url and bodyText:
            draft_response = await run_agentspace_url_query(agentspace_ai_url, bodyText)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            return draft_response
        return ""
    except Exception as e:
        return ""

# --- Placeholder Tool Agents ---
# These agents would contain the logic for calling a specific tool
class HardwareToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in HardwareToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class SoftwareToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in SoftwareToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class GenericITToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in GenericITToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class WindowsToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in WindowsToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class UnixToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in UnixToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class NetworkToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in NetworkToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class PolicyToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in PolicyToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class CustomerAccountToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in CustomerAccountToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class FAQToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in FAQToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class CustomerDataToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in CustomerDataToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class CustomerPaymentToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in CustomerPaymentToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class CustomerMeterToolAgent(BaseAgent):
    """
    Agent for handling customer meter-related requests.
    Includes a method to add a custom acknowledgement to the response.
    """
    def _add_meter_update_acknowledgement(self, draft_response: str) -> str:
        """
        Adds a custom acknowledgement message to the end of the draft response.
        This can be a template for other specific customizations.
        """
        acknowledgement_text = "\n\nNote: A meter update has been applied to the customer's record."
        return draft_response + acknowledgement_text

    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            customized_response = ""
            # Check if an email draft was successfully generated
            customer_name = ctx.session.state.get("email_parser_obj",{}).get("customer_name","unknown")
            customer_id = ctx.session.state.get("email_parser_obj",{}).get("customer_id","unknown")
            date_range = ctx.session.state.get("email_parser_obj",{}).get("date_range","unknown")
            meter_reading = ctx.session.state.get("email_parser_obj",{}).get("meter_reading","unknown")
            if customer_name == "unknown" or \
               customer_id == "unknown" or \
               meter_reading == "unknown" or \
               date_range == "unknown":
                customized_response = "You have not specified all the required customer name, id, meter reading or date range details"
            else:
                rewritten_query = f"Is there a customer with the customer_id {customer_id}?"
                # Call the Agentspace AI URL to get the initial draft
                draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
                if isinstance(draft_response, list):
                    draft_response = "\n\n".join(draft_response)
                
                if "yes" in draft_response.lower():
                    # Call the new method to add the custom acknowledgement
                    draft_response = "The customer exists in the system"
                    customized_response = self._add_meter_update_acknowledgement(draft_response)
                else:
                    customized_response = "The customer specified does not exist in the system"

            ctx.session.state["tool_result"] = customized_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=customized_response)]))
        except Exception as e:
            error_msg = f"Exception in CustomerMeterToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

class OtherToolAgent(BaseAgent):
    @override
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        try:
            rewritten_query = ctx.session.state.get("rewritten_query", ctx.session.state.get("topic"))
            draft_response = await run_agentspace_url_query(utils.getValue("AGENTSPACE_AI_URL"), rewritten_query)
            if isinstance(draft_response, list):
                draft_response = "\n\n".join(draft_response)
            ctx.session.state["tool_result"] = draft_response
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=draft_response)]))
        except Exception as e:
            error_msg = f"Exception in OtherToolAgent: {e}"
            ctx.session.state["tool_result"] = error_msg
            yield Event(author=self.name, content=types.Content(role="model", parts=[types.Part(text=error_msg)]))

# --- Custom Orchestrator Agent ---
class CustomEmailProcessorAgent(BaseAgent):
    """
    An ADK agent that orchestrates a multi-step workflow for processing IT support emails.

    The workflow includes:
     1. Receives customer support requests.
     2. Drafts an email response to the customer.
     3. Reviews the email draft for tone and quality.
     4. Finalizes the draft for a human to review.
    """
    # --- Field Declarations for Pydantic ---
    queryRewriter: LlmAgent
    sentimentReviewer: LlmAgent
    emailParser: LlmAgent
    emailGenerator: LlmAgent
    emailReviewer: LlmAgent
    emailReviser: LlmAgent # New agent for revising the email
    loop_agent: LoopAgent
    sequential_agent: SequentialAgent
    revision_agent: SequentialAgent # New agent for the revision step

    model_config = {"arbitrary_types_allowed": True}

    def __init__(
        self,
        name: str,
        queryRewriter: LlmAgent,
        sentimentReviewer: LlmAgent,
        emailParser: LlmAgent,
        emailGenerator: LlmAgent,
        emailReviewer: LlmAgent,
        emailReviser: LlmAgent,
    ):
        """
        Initializes the custom email processing agent and its sub-agents.

        Args:
            name: The name of the agent.
            queryRewriter: The agent for rewriting the query.
            sentimentReviewer: The agent for sentiment analysis.
            emailParser: The agent for parsing email details
            emailGenerator: The agent for generating the initial email draft.
            emailReviewer: The agent for reviewing the email draft.
            emailReviser: The agent for revising the email based on feedback.
        """
        # A sequential agent to perform the initial sentiment analysis and email generation
        sequential_agent = SequentialAgent(
            name="GenerateEmail", sub_agents=[sentimentReviewer, emailParser, queryRewriter]
        )
        # A sequential agent for the review and revise loop
        revision_agent = SequentialAgent(
            name="ReviewAndReviseEmail", sub_agents=[emailReviewer, emailReviser]
        )
        # A loop agent that repeatedly calls the revision agent until a condition is met
        loop_agent = LoopAgent(
            name="ReviewEmail", sub_agents=[revision_agent], max_iterations=5
        )

        sub_agents_list = [
            sequential_agent,
            loop_agent,
        ]

        # Call the parent class's constructor with all sub-agents
        super().__init__(
            name=name,
            queryRewriter=queryRewriter,
            sentimentReviewer=sentimentReviewer,
            emailParser=emailParser,
            emailGenerator=emailGenerator,
            emailReviewer=emailReviewer,
            emailReviser=emailReviser,
            sequential_agent=sequential_agent,
            revision_agent=revision_agent,
            loop_agent=loop_agent,
            sub_agents=sub_agents_list,
        )

    @staticmethod
    def extract_user_text(session) -> str | None:
        """
        Safely extracts the text content from the first event in a session.
        This handles different session event structures and returns None if text is not found.
        """
        try:
            events = session["events"]
            first_part = events[0]["content"]["parts"][0]
            return first_part["text"]
        except (KeyError, IndexError, TypeError):
            pass

        try:
            ev = session.events[0]
            part = ev.content.parts[0]
            return part.text
        except (AttributeError, IndexError):
            return None

    @override
    async def _run_async_impl(
        self,
        ctx: InvocationContext,
    ) -> AsyncGenerator[Event, None]:
        """
        Implements the main asynchronous execution logic for the custom agent.

        Args:
            ctx: The invocation context containing session state and new messages.

        Yields:
            Event: An event representing a step in the agent's workflow.
        """

        # Set default values for optional email context fields to prevent KeyErrors later
        ctx.session.state.setdefault("from_email_address", "a customer")
        ctx.session.state.setdefault("subject", "a new support request")

        # Check for a new message and parse it
        bodyText = None
        user_message_text = None

        # Prefer new_message if present
        if getattr(ctx.session, "new_message", None) and getattr(ctx.session.new_message, "parts", None):
            part = ctx.session.new_message.parts[0]
            user_message_text = getattr(part, "text", None)

        # Fallback: extract from session events
        if user_message_text is None:
            user_message_text = CustomEmailProcessorAgent.extract_user_text(ctx.session)

        if user_message_text is not None:
            try:
                payload = json.loads(user_message_text)
                email_context = EmailContext.model_validate(payload)
                ctx.session.state["from_email_address"] = email_context.fromEmailAddress
                ctx.session.state["subject"] = email_context.subject
                user_input_topic = email_context.body
                bodyText = email_context.body
                ctx.session.state["topic"] = user_input_topic
            except (json.JSONDecodeError, ValidationError):
                ctx.session.state["topic"] = user_message_text
                bodyText = user_message_text
        
        original_query = bodyText
        
        # Run the sentiment analysis and query rewriter
        async for event in self.sequential_agent.run_async(ctx):
            yield event

        rewritten_query = ctx.session.state.get("rewritten_query", original_query)
        email_intention = ctx.session.state.get("email_sentiment_obj", {}).get("intention")

        if email_intention == 'Hardware Issue':
            async for event in HardwareToolAgent(name="HardwareToolAgent").run_async(ctx):
                yield event
        elif email_intention == 'Software Issue':
            async for event in SoftwareToolAgent(name="SoftwareToolAgent").run_async(ctx):
                yield event
        elif email_intention == 'Windows IT Issue':
            async for event in WindowsToolAgent(name="WindowsToolAgent").run_async(ctx):
                yield event
        elif email_intention == 'Unix IT Issue':
            async for event in UnixToolAgent(name="UnixToolAgent").run_async(ctx):
                yield event
        elif email_intention == 'Network Issue':
            async for event in NetworkToolAgent(name="NetworkToolAgent").run_async(ctx):
                yield event
        elif email_intention == 'Policy Question':
            async for event in PolicyToolAgent(name="PolicyToolAgent").run_async(ctx):
                yield event
        elif email_intention == 'Customer Account Issue':
            async for event in CustomerAccountToolAgent(name="CustomerAccountToolAgent").run_async(ctx):
                yield event
        elif email_intention == 'FAQ Request':
            async for event in FAQToolAgent(name="FAQToolAgent").run_async(ctx):
                yield event
        elif email_intention == 'Customer Data Request':
            async for event in CustomerDataToolAgent(name="CustomerDataToolAgent").run_async(ctx):
                yield event
        elif email_intention == 'Customer Payment Request':
            async for event in CustomerPaymentToolAgent(name="CustomerPaymentToolAgent").run_async(ctx):
                yield event
        elif email_intention == 'Customer Meter Request':
            async for event in CustomerMeterToolAgent(name="CustomerMeterToolAgent").run_async(ctx):
                yield event
        elif email_intention == 'Other':
            async for event in OtherToolAgent(name="OtherToolAgent").run_async(ctx):
                yield event
        else: # Fallback for 'Generic IT Issue' or any unhandled category
            async for event in GenericITToolAgent(name="GenericITToolAgent").run_async(ctx):
                yield event

        async for event in self.emailGenerator.run_async(ctx):
            yield event

        # Check if an email draft was successfully generated
        email_draft = ctx.session.state.get("email_draft")
        if not email_draft or not str(email_draft).strip():
            return
        
        # 3. Reviewer Loop for continuous revision
        # The LoopAgent calls the revision_agent (which contains the reviewer and reviser) until the condition is met.
        async for event in self.loop_agent.run_async(ctx):
            yield event
            email_review_comments = ctx.session.state.get("email_review_comments","").strip()
            # Stop the loop if reviewer says "No further comments"
            if "No further comments." in email_review_comments:
                break

        # 4. Finalize and return the result
        final_session = ctx.session
        result = {
            "email_data": {
                "fromEmailAddress": final_session.state.get("from_email_address"),
                "subject": final_session.state.get("subject"),
                "body": bodyText,
            },
            "answer": {
                "email_draft": final_session.state.get("email_draft"),
                "tool_results": final_session.state.get("tool_result", "No tool was explicitly called."),
            },
            "metadata": {
                "email_sentiment": final_session.state.get("email_sentiment_obj", {}).get("sentiment"),
                "email_intention": final_session.state.get("email_sentiment_obj", {}).get("intention"),
                "email_urgency": final_session.state.get("email_sentiment_obj", {}).get("urgency"),
                "email_review_comments": final_session.state.get("email_review_comments").split("\n\n")[-1].strip()
            }
        }
        final_content = types.Content(
            role="model",
            parts=[types.Part(text=json.dumps(result, indent=2))]
        )

        # Yield the final event with the complete, structured response
        yield Event(
            author="CustomEmailProcessorAgent",
            content=final_content,
        )

        return

# --- Pydantic Schemas for structured input/output ---
class EmailContext(BaseModel):
    """Pydantic model for structured JSON email input."""
    fromEmailAddress: str = Field(None, description="The sender's email address.")
    subject: str = Field(None, description="The subject line of the email.")
    body: str = Field(..., description="The body of the email.")
    dateTime: str = Field(None, description="The date and time the email was sent.")

class EmailSentiment(BaseModel):
    """Pydantic model for structured sentiment output from the LLM."""
    sentiment: str = Field(description="The single word sentiment label of the email.")
    intention: str = Field(description="The single action statement about what the action is this email needs to result in doing.")
    urgency:   str = Field(description="Optional urgency level of the email.")

class EmailParser(BaseModel):
    """Pydantic model for structured parser output from the LLM."""
    customer_name: str = Field(description="The customer name.")
    customer_id: str = Field(description="The customer id.")
    date_range:   str = Field(description="The date range.")
    meter_reading: str = Field(description="The meter reading.")

# --- LLM Agent Instructions ---
helpbot_instruction = (
    "You are HelpBot, an automated IT helpdesk email chatbot for a corporate IT support desk. "
    "You know common IT problems with Windows and Linux. "
    "Respond professionally and empathetically in email format for semi-IT literate users. "
    "Limit responses to IT, HR, FAQ, Customer issues, Customer meter updates and policy topics only. "
    "Be truthful, never lie or make up facts; if unsure, explain why. "
    "Cite references when possible. "
    "Request further info with clear steps if needed. "
    "If unable to resolve, state any additional info needed to escalate or other sources to consult. "
    "When providing instructions or lists, use numbered lists. Use **bold** for emphasis on key words or phrases. "
    "Return the full email text as HTML only, do not return any other text. Wrap the response in <html><body>...</body></html> tags. "
    "You may use multiple paragraphs, headings, and ordered/unordered lists to structure your response, and you may use simple HTML tags like <b> and <p> for emphasis."
)

reviewer_instruction = (
    "You are an expert email reviewer. Review the email provided: {{email_draft}}. Provide 1-2 sentences of constructive criticism "
    "on how to improve it. Focus on clarity, tone, and professionalism."
    "When your are finished reviewing and have nothing more to add, respond with 'No further comments.'"
)

reviser_instruction = (
    "You are an expert email reviser. You have been given an email draft: {{email_draft}} and review comments: {{email_review_comments}}. "
    "Your task is to apply the review comments to the email draft to create a new, improved draft. "
    "Return only the revised email draft, with no additional commentary."
)

sentiment_instruction = (
    "You are an expert in analyzing email sentiment. Review the email provided: {{topic}}. "
    "Output ONLY the following: "
    "1. A single sentiment label as specified in the schema. "
    "2. A single action statement about what the action is this email needs to result in doing. You will need to catagorize the intention. "
    "   into the following categories: 'Generic IT Issue', ''Windows IT Issue', 'Unix IT Issue', 'Hardware Issue', 'Software Issue', 'Network Issue', "
    "   'Policy Question', 'Customer Account Issue', 'FAQ Request', 'Customer Data Request', 'Customer Payment Request', "
    "   'Customer Meter Request', 'Other'. "
    "3. A single urgency label for the email, depending on if it is clearly urgent or high priority. Categories are 'Low', 'Medium', 'High', or 'Critical'. "
    "   If not clearly specified, return 'Normal'. "
    "Format your response as a JSON object matching the EmailSentiment schema. "
    "Do not output anything else."
)

query_rewriter_instruction = (
    "You are an expert on Agentspace AI apps. "
    "Your role is to ensure Agentspace AI apps RESTful API will return a relevant answer. "
    "Rewrite the following text - {{topic}} - into a direct, succinct question that an AI knowledge base can easily answer. "
    "The question should begin with 'what' or a similar interrogative. Return only the rephrased question."
)

parser_instruction = (
    "You are an expert in analyzing email contents. Review the email provided: {{topic}}. "
    "Output ONLY the following: "
    "1. A single customer name as specified in the schema. "
    "2. A single customer id as specified in the schema."
    "3. A date range for an account as specified in the schema. This must have a start date and an end date. "
    "   If only one is specified, use the same date for start and end. "
    "   If not specified, return 'unknown'. "
    "4. A single meter reading as specified in the schema. "
    "Format your response as a JSON object matching the EmailParser schema. "
    "If not specified, return 'unknown'. "
    "Do not output anything else."
)

# --- Define the individual LLM agents ---
queryRewriter = LlmAgent(
    name="QueryRewriter",
    model=MODEL,
    instruction=query_rewriter_instruction,
    output_key="rewritten_query"
)

emailGenerator = LlmAgent(
    name="EmailGenerator",
    model=MODEL,
    generate_content_config=types.GenerateContentConfig(
        temperature=0.8,
        top_p=1,
    ),
    instruction=helpbot_instruction + (
        " Generate the complete email draft for the following customer inquiry: {{topic}}. "
        "The original email was from {{from_email_address}} with the subject '{{subject}}'."
        "Use the tool result if available: {{tool_result}} to help inform your response. "
        "Provide ONLY the email content, with no introductory or concluding remarks."
    ),
    input_schema=None,
    output_schema=None,
    output_key="email_draft",
)

emailReviewer = LlmAgent(
    name="EmailReviewer",
    model=MODEL,
    generate_content_config=types.GenerateContentConfig(
        temperature=0.8,
        top_p=1,
    ),
    instruction=reviewer_instruction,
    input_schema=None,
    output_schema=None,
    output_key="email_review_comments",
)

# NEW: Agent for revising the email
emailReviser = LlmAgent(
    name="EmailReviser",
    model=MODEL,
    generate_content_config=types.GenerateContentConfig(
        temperature=0.8,
        top_p=1,
    ),
    instruction=reviser_instruction,
    input_schema=None,
    output_schema=None,
    output_key="email_draft", # Overwrite the email_draft with the revised version
)

sentimentReviewer = LlmAgent(
    name="EmailSentimentReviewer",
    model=MODEL,
    generate_content_config=types.GenerateContentConfig(
        temperature=0.8,
        top_p=1,
    ),
    instruction=sentiment_instruction,
    input_schema=None,
    output_schema=EmailSentiment,
    output_key="email_sentiment_obj",
)

emailParser = LlmAgent(
    name="EmailParser",
    model=MODEL,
    generate_content_config=types.GenerateContentConfig(
        temperature=0.8,
        top_p=1,
    ),
    instruction=parser_instruction,
    input_schema=None,
    output_schema=EmailParser,
    output_key="email_parser_obj",
)

# --- Create the custom agent instance ---
root_agent = CustomEmailProcessorAgent(
    name="CustomEmailProcessorAgent",
    queryRewriter=queryRewriter,
    sentimentReviewer=sentimentReviewer,
    emailParser=emailParser, # Pass the new agent here
    emailGenerator=emailGenerator,
    emailReviewer=emailReviewer,
    emailReviser=emailReviser,
)

# --- Main Execution Block for a local, working example ---
async def setup_session_and_runner(user_id: str, session_id: str, email_topic: str):
    """
    Sets up an ADK session and a Runner for local testing.
    """
    INITIAL_STATE = {"topic": email_topic}

    session_service = InMemorySessionService()
    session = await session_service.create_session(app_name=APP_NAME,
                                                   user_id=user_id,
                                                   session_id=session_id,
                                                   state=INITIAL_STATE)

    runner = Runner(
        agent=root_agent, # Pass the custom orchestrator agent
        app_name=APP_NAME,
        session_service=session_service
    )
    return session_service, runner

# --- Function to Interact with the Agent ---
async def call_agent_async(user_input_topic: str, logger: logging.Logger):
    """
    Sends a new topic to the agent and runs the workflow.
    
    Args:
        user_input_topic: The user's input, which can be a JSON string or plain text.
        logger: The logger object to use for logging.
    """
    user_id = str(uuid.uuid4())
    session_id = str(uuid.uuid4())

    session_service, runner = await setup_session_and_runner(user_id, session_id, user_input_topic)

    current_session = await session_service.get_session(app_name=APP_NAME,
                                                  user_id=user_id,
                                                  session_id=session_id)
    if not current_session:
        return

    current_session.state["topic"] = user_input_topic

    content = types.Content(
        role='user',
        parts=[types.Part(text=user_input_topic)]
    )

    events = runner.run_async(user_id=user_id,
                              session_id=session_id,
                              new_message=content)

    final_response = "No final response captured."
    async for event in events:
        if event.is_final_response() and event.content and event.content.parts:
            final_response = event.content.parts[0].text
    
    # Return the captured final response directly
    return final_response