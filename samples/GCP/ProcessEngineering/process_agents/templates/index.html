<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Process Viewer</title>
    <style>
        :root {
            --bg: #f5f5f5;
            --bg-panel: #ffffff;
            --bg-lane-even: #ffffff;
            --bg-lane-odd: #f0f0f0;
            --border: #cccccc;
            --text: #222222;
            --muted: #555555;
            --accent: #0077cc;
            --accent-2: #ff6600;
            --node-fill: #ffffff;
            --node-stroke: #333333;
            --minimap-bg: #ffffff;
        }

        :root.dark {
            --bg: #111111;
            --bg-panel: #1e1e1e;
            --bg-lane-even: #1a1a1a;
            --bg-lane-odd: #151515;
            --border: #444444;
            --text: #f0f0f0;
            --muted: #aaaaaa;
            --accent: #4ea3ff;
            --accent-2: #ffb347;
            --node-fill: #222222;
            --node-stroke: #dddddd;
            --minimap-bg: #222222;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
        }

        #breadcrumb {
            padding: 8px 12px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #breadcrumb span {
            cursor: default;
        }

        #breadcrumb .crumb-clickable {
            cursor: pointer;
            font-weight: 600;
        }

        #top-controls {
            margin-left: auto;
            display: flex;
            gap: 8px;
        }

        #top-controls button {
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        #container {
            display: flex;
            height: calc(100vh - 40px);
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: var(--bg);
            overflow: hidden;
        }

        #info-panel {
            width: 340px;
            border-left: 1px solid var(--border);
            background: var(--bg-panel);
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        #process-title {
            margin-top: 0;
            margin-bottom: 6px;
            font-size: 18px;
        }

        #search-box {
            margin-bottom: 10px;
            width: 100%;
            padding: 6px;
            font-size: 14px;
            box-sizing: border-box;
        }

        #lane-filters {
            margin-bottom: 10px;
            font-size: 13px;
        }

        #lane-filters label {
            display: block;
            cursor: pointer;
        }

        .lane-label {
            font-weight: bold;
            fill: var(--text);
        }

        .node rect {
            fill: var(--node-fill);
            stroke: var(--node-stroke);
            stroke-width: 1.4;
        }

        .node text {
            pointer-events: none;
            fill: var(--text);
        }

        .info-icon {
            cursor: pointer;
            font-size: 14px;
            fill: var(--accent);
            pointer-events: all;
        }

        .duration-text {
            fill: var(--muted);
            font-size: 12px;
        }

        .io-text-input {
            fill: var(--accent);
            font-size: 11px;
        }

        .io-text-output {
            fill: var(--accent-2);
            font-size: 11px;
        }

        .highlight {
            stroke: var(--accent-2) !important;
            stroke-width: 3 !important;
        }

        #diagram {
            background: var(--bg);
        }

        #minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 120px;
            border: 1px solid var(--border);
            background: var(--minimap-bg);
            opacity: 0.85;
            z-index: 20;
        }

        #minimap-viewport {
            fill: none;
            stroke: red;
            stroke-width: 1.5;
            pointer-events: none;
        }

        #reset-zoom-btn {
            position: absolute;
            top: 10px;
            z-index: 10;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        #zoom-in-btn,
        #zoom-out-btn {
            position: absolute;
            top: 10px;
            z-index: 100;
            padding: 4px 8px;
            font-size: 14px;
            cursor: pointer;
        }

        #zoom-in-btn {
            right: 130px;
        }

        #zoom-out-btn {
            right: 100px;
        }

        #reset-zoom-btn {
            right: 10px;
        }

        #modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #modal {
            background: var(--bg-panel);
            color: var(--text);
            padding: 16px;
            max-width: 520px;
            max-height: 70vh;
            overflow-y: auto;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            box-sizing: border-box;
        }

        #modal h3 {
            margin-top: 0;
        }

        #modal pre {
            background: rgba(0, 0, 0, 0.05);
            padding: 8px;
            font-size: 12px;
            overflow-x: auto;
        }

        #modal button {
            margin-top: 8px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        a {
            color: var(--accent);
        }
    </style>
</head>

<body>
    <!-- Breadcrumb + top controls -->
    <div id="breadcrumb">
        <span id="crumb-level1" class="crumb-clickable">Level 1</span>
        <span id="crumb-sep" style="display:none;">→</span>
        <span id="crumb-step" class="crumb-clickable" style="display:none;"></span>

        <div id="top-controls">
            <button id="dark-toggle-btn">Dark mode</button>
        </div>
    </div>

    <div id="container">
        <div id="canvas-container">
            <svg id="diagram" width="100%" height="100%">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                        <path d="M0,0 L10,3.5 L0,7 Z" fill="#888"></path>
                    </marker>
                </defs>
                <g id="viewport"></g>
            </svg>

            <svg id="minimap">
                <g id="minimap-content"></g>
                <rect id="minimap-viewport"></rect>
            </svg>

            <button id="zoom-in-btn">+</button>
            <button id="zoom-out-btn">-</button>
            <button id="reset-zoom-btn">Reset Zoom</button>

        </div>

        <div id="info-panel">
            <h2 id="process-title">Loading...</h2>

            <input id="search-box" placeholder="Search steps..." />

            <div id="lane-filters"></div>

            <p style="font-size:13px; color:var(--muted);">
                Double-click a Level 1 step to drill into its subprocess.<br>
                Click the ℹ️ icon on a step to see details.<br>
                Use search to highlight matching steps.
            </p>
        </div>
    </div>

    <!-- Modal -->
    <div id="modal-backdrop">
        <div id="modal">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h3 id="modal-title" style="margin:0;"></h3>
                <span id="modal-close" style="cursor:pointer; font-size:20px; padding:4px 8px; line-height:1;">
                    <svg width="20" height="20" viewBox="0 0 20 20" aria-label="Close" style="display:block;">
                        <rect x="4" y="4" width="12" height="12" rx="2" fill="none" stroke="currentColor" stroke-width="1.5"/>
                        <line x1="7" y1="7" x2="13" y2="13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                        <line x1="13" y1="7" x2="7" y2="13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </span>
            </div>

            <div id="modal-body" style="max-height:60vh; overflow-y:auto;"></div>

            <button onclick="closeModal()">Close</button>
        </div>
    </div>

    <script>
        // --- Globals ---
        let processModel = null;
        let currentLevel = 1;
        let currentParentStep = null;

        let lanes = [];

        function buildLanesFromProcess(processModel) {
            const laneSet = new Set();

            // Level 1
            (processModel.level1_steps || []).forEach(step => {
                const r = normalizeResponsible(step.responsible_party);
                if (r) laneSet.add(r);
            });

            // Level 2
            Object.values(processModel.subprocess_index || {}).forEach(substeps => {
                substeps.forEach(sub => {
                    const r = normalizeResponsible(sub.responsible_party);
                    if (r) laneSet.add(r);
                });
            });

            // Convert to array
            lanes = Array.from(laneSet);

            // Fallback if JSON has no responsible_party fields
            if (lanes.length === 0) {
                lanes = ["Process"];
            }
        }


        let zoomScale = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        let activeLaneVisibility = {
            "Sales Associates": true,
            "Store Manager": true,
            "Inventory Management Team": true,
            "Process": true
        };

        // --- Utility: SVG creation ---
        function createSvgElement(tag, attrs) {
            const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
            for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
            return el;
        }

        function normalizeResponsible(responsible) {
            if (!responsible) return null;
            if (Array.isArray(responsible)) return responsible[0];
            return responsible;
        }

        // --- Load process model ---
        async function loadProcess() {
            const res = await fetch("/api/process");
            processModel = await res.json();
            buildLanesFromProcess(processModel);
            document.getElementById("process-title").textContent = processModel.process_name || "Process";
            renderLevel1();
            enableZoomPan();
            enableSearch();
            enableLaneFilters();
            enableDarkModeToggle();
        }

        // --- Clear diagram ---
        function clearDiagram() {
            const viewport = document.getElementById("viewport");
            while (viewport.firstChild) viewport.removeChild(viewport.firstChild);
        }

        // --- Layout engine: compute node positions based on text width ---
        function measureTextWidth(text, fontSize = 14, fontFamily = "system-ui") {
            const canvas = measureTextWidth._canvas || (measureTextWidth._canvas = document.createElement("canvas"));
            const ctx = canvas.getContext("2d");
            ctx.font = `${fontSize}px ${fontFamily}`;
            return ctx.measureText(text).width;
        }

        function layoutSteps(steps, laneHeight, baseMarginX) {
            const nodes = [];
            const minWidth = 180;
            const maxWidth = 380;
            const hGap = 60;

            let currentX = baseMarginX;

            steps.forEach((step, idx) => {
                const label = step.step_name || step.substep_name || "Step";
                const laneName = normalizeResponsible(step.responsible_party) || "Process";
                const laneIndex = lanes.indexOf(laneName);
                const laneIdx = laneIndex >= 0 ? laneIndex : 3;

                const textWidth = measureTextWidth(label, 14);
                const width = Math.min(maxWidth, Math.max(minWidth, textWidth + 40));
                const height = 70;

                const yCenter = laneIdx * laneHeight + laneHeight / 2;
                const x = currentX;
                const y = yCenter - height / 2;

                nodes.push({
                    step,
                    label,
                    laneName,
                    laneIndex: laneIdx,
                    x,
                    y,
                    width,
                    height,
                    centerX: x + width / 2,
                    centerY: yCenter
                });

                currentX += width + hGap;
            });

            return nodes;
        }

        // --- Draw lanes ---
        function drawLanes(viewport, width, laneHeight) {
            lanes.forEach((lane, i) => {
                const y = i * laneHeight;
                const laneRect = createSvgElement("rect", {
                    x: 0,
                    y,
                    width,
                    height: laneHeight,
                    fill: i % 2 === 0 ? "var(--bg-lane-even)" : "var(--bg-lane-odd)",
                    stroke: "var(--border)"
                });
                viewport.appendChild(laneRect);

                const label = createSvgElement("text", {
                    x: 10,
                    y: y + 20,
                    class: "lane-label"
                });
                label.textContent = lane;
                viewport.appendChild(label);
            });
        }

        // --- Draw curved arrow between nodes ---
        function drawArrow(viewport, fromNode, toNode) {
            const x1 = fromNode.x + fromNode.width;
            const y1 = fromNode.centerY;
            const x2 = toNode.x;
            const y2 = toNode.centerY;

            const dx = (x2 - x1) / 2;
            const control1X = x1 + dx;
            const control1Y = y1;
            const control2X = x2 - dx;
            const control2Y = y2;

            const pathData = `M ${x1} ${y1} C ${control1X} ${control1Y}, ${control2X} ${control2Y}, ${x2} ${y2}`;

            const path = createSvgElement("path", {
                d: pathData,
                fill: "none",
                stroke: "#888",
                "stroke-width": 2,
                "marker-end": "url(#arrowhead)"
            });

            viewport.appendChild(path);
        }

        // --- Draw node ---
        function drawNode(viewport, node, level) {
            const { x, y, width, height, label, step } = node;
            const duration = step.estimated_duration || "";
            const inputs = step.inputs || [];
            const outputs = step.deliverables || step.outputs || [];

            const group = createSvgElement("g", {
                class: "node",
                "data-label": label,
                "data-lane": node.laneName
            });

            group.addEventListener("dblclick", () => {
                if (level === 1) renderLevel2(label);
            });

            const rect = createSvgElement("rect", {
                x,
                y,
                width,
                height,
                rx: 6,
                ry: 6
            });
            group.appendChild(rect);

            const text = createSvgElement("text", {
                x: x + 10,
                y: y + 24,
                "font-size": "14px"
            });
            text.textContent = label;
            group.appendChild(text);

            if (duration) {
                const durText = createSvgElement("text", {
                    x: x + 10,
                    y: y + 44,
                    class: "duration-text"
                });
                durText.textContent = `Duration: ${duration}`;
                group.appendChild(durText);
            }

            inputs.forEach((inp, idx) => {
                const t = createSvgElement("text", {
                    x: x + width / 2,
                    y: y - 10 - idx * 12,
                    "text-anchor": "middle",
                    class: "io-text-input"
                });
                t.textContent = `↑ ${inp}`;
                group.appendChild(t);
            });

            outputs.forEach((out, idx) => {
                const t = createSvgElement("text", {
                    x: x + width / 2,
                    y: y + height + 14 + idx * 12,
                    "text-anchor": "middle",
                    class: "io-text-output"
                });
                t.textContent = `${out} ↓`;
                group.appendChild(t);
            });

            // Position the icon relative to the box's top-right corner
            const infoGroup = createSvgElement("g", {
                transform: `translate(${x + width - 22}, ${y + 18})`,
                style: "pointer-events: all; cursor: pointer;"
            });

            const hitbox = createSvgElement("rect", {
                x: 0, y: -13,
                width: 15,
                height: 15, fill: "transparent"
            });

            infoGroup.appendChild(hitbox);

            // The icon itself
            const infoText = createSvgElement("text", {
                x: 0,
                y: 0,
                class: "info-icon"
            });
            infoText.textContent = "ℹ️";
            infoGroup.appendChild(infoText);

            infoGroup.addEventListener("click", (e) => {
                e.stopPropagation();
                showInfo(step, label);
            });

            group.appendChild(infoGroup);
            viewport.appendChild(group);
        }
    </script>
    <script>
        // --- Breadcrumb ---
        function updateBreadcrumb(level, parentStep = null) {
            const c1 = document.getElementById("crumb-level1");
            const sep = document.getElementById("crumb-sep");
            const cStep = document.getElementById("crumb-step");

            if (level === 1) {
                sep.style.display = "none";
                cStep.style.display = "none";
            } else {
                sep.style.display = "inline";
                cStep.style.display = "inline";
                cStep.textContent = parentStep;
            }
        }

        document.getElementById("modal-close").onclick = closeModal;
        document.getElementById("crumb-level1").onclick = () => {
            renderLevel1();
        };

        document.getElementById("crumb-step").onclick = () => {
            if (currentParentStep) renderLevel2(currentParentStep);
        };

        // --- Modal ---
        function showInfo(step, title) {
            const modalTitle = document.getElementById("modal-title");
            const modalBody = document.getElementById("modal-body");

            modalTitle.textContent = title;

            const FIELD_ORDER = [
                "step_name",
                "substep_name",
                "description",
                "estimated_duration",
                "responsible_party",
                "inputs",
                "deliverables",
                "outputs",
                "dependencies",
                "success_criteria"
            ];

            let html = `
    <table style="
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
        table-layout: fixed;
    ">
      <thead>
        <tr style="background: #444; color: #fff;">
          <th style="padding: 6px; border: 1px solid #ccc; text-align: left;">Key</th>
          <th style="padding: 6px; border: 1px solid #ccc; text-align: left;">Value</th>
        </tr>
      </thead>
      <tbody>
    `;

            const addRow = (key, valueHtml, rowIndex) => {
                const bg = rowIndex % 2 === 0 ? "#fff" : "#f2f2f2";
                html += `
        <tr style="background: ${bg};">
          <td style="padding: 6px; border: 1px solid #ccc; vertical-align: top; word-wrap: break-word;">
            ${key}
          </td>
          <td style="padding: 6px; border: 1px solid #ccc; vertical-align: top; word-wrap: break-word;">
            ${valueHtml}
          </td>
        </tr>
        `;
            };

            let rowIndex = 0;

            // Render fields in defined order
            FIELD_ORDER.forEach(key => {
                if (!(key in step)) return;

                const value = step[key];

                if (Array.isArray(value)) {
                    if (value.length === 0) return;
                    const list = value.map(v => `<li>${v}</li>`).join("");
                    addRow(key, `<ul style="margin:0; padding-left:18px;">${list}</ul>`, rowIndex++);
                } else if (typeof value === "object" && value !== null) {
                    addRow(key, `<pre style="margin:0;">${JSON.stringify(value, null, 2)}</pre>`, rowIndex++);
                } else {
                    addRow(key, String(value), rowIndex++);
                }
            });

            // Render any remaining fields not in FIELD_ORDER
            Object.entries(step).forEach(([key, value]) => {
                if (FIELD_ORDER.includes(key)) return;

                if (Array.isArray(value)) {
                    if (value.length === 0) return;
                    const list = value.map(v => `<li>${v}</li>`).join("");
                    addRow(key, `<ul style="margin:0; padding-left:18px;">${list}</ul>`, rowIndex++);
                } else if (typeof value === "object" && value !== null) {
                    addRow(key, `<pre style="margin:0;">${JSON.stringify(value, null, 2)}</pre>`, rowIndex++);
                } else {
                    addRow(key, String(value), rowIndex++);
                }
            });

            html += `</tbody></table>`;
            modalBody.innerHTML = html;
            document.getElementById("modal-backdrop").style.display = "flex";
        }

        function closeModal() {
            document.getElementById("modal-backdrop").style.display = "none";
        }
        window.closeModal = closeModal;

        // --- Render Level 1 ---
        function renderLevel1() {
            currentLevel = 1;
            currentParentStep = null;
            clearDiagram();
            updateBreadcrumb(1);
            resetZoom();

            const svg = document.getElementById("diagram");
            const viewport = document.getElementById("viewport");
            const width = svg.clientWidth || 1000;
            const height = svg.clientHeight || 600;

            const minLaneHeight = 170;
            const laneHeight = Math.max(minLaneHeight, height / lanes.length);
            drawLanes(viewport, width, laneHeight);

            const steps = processModel.level1_steps || [];
            const visibleSteps = steps.filter(step => {
                const laneName = normalizeResponsible(step.responsible_party) || "Process";
                return activeLaneVisibility[laneName] !== false;
            });

            const nodes = layoutSteps(visibleSteps, laneHeight, 160);

            nodes.forEach(node => drawNode(viewport, node, 1));

            for (let i = 0; i < nodes.length - 1; i++) {
                drawArrow(viewport, nodes[i], nodes[i + 1]);
            }

            updateMinimap();
        }

        // --- Render Level 2 ---
        function renderLevel2(parentStepName) {
            currentLevel = 2;
            currentParentStep = parentStepName;
            clearDiagram();
            updateBreadcrumb(2, parentStepName);
            resetZoom();

            const svg = document.getElementById("diagram");
            const viewport = document.getElementById("viewport");
            const width = svg.clientWidth || 1000;
            const height = svg.clientHeight || 600;

            const minLaneHeight = 170;
            const laneHeight = Math.max(minLaneHeight, height / lanes.length);
            drawLanes(viewport, width, laneHeight);

            const flow = processModel.subprocess_index[parentStepName] || [];
            const visibleSteps = flow.filter(step => {
                const laneName = normalizeResponsible(step.responsible_party) || "Process";
                return activeLaneVisibility[laneName] !== false;
            });

            const nodes = layoutSteps(visibleSteps, laneHeight, 160);

            nodes.forEach(node => drawNode(viewport, node, 2));

            for (let i = 0; i < nodes.length - 1; i++) {
                drawArrow(viewport, nodes[i], nodes[i + 1]);
            }

            updateMinimap();
        }

        // --- Zoom & Pan ---
        function enableZoomPan() {
            const svg = document.getElementById("diagram");

            svg.addEventListener("wheel", (e) => {
                e.preventDefault();
                const scaleAmount = e.deltaY * -0.001;
                zoomScale = Math.min(Math.max(0.2, zoomScale + scaleAmount), 3);
                updateTransform();
                updateMinimap();
            });

            // Zoom In button
            document.getElementById("zoom-in-btn").addEventListener("click", () => {
                zoomScale = Math.min(zoomScale + 0.1, 3);
                updateTransform();
                updateMinimap();
            });

            // Zoom Out button
            document.getElementById("zoom-out-btn").addEventListener("click", () => {
                zoomScale = Math.max(zoomScale - 0.1, 0.2);
                updateTransform();
                updateMinimap();
            });

            svg.addEventListener("mousedown", (e) => {
                if (e.button !== 0) return;
                isPanning = true;
                panStart = { x: e.clientX - panX, y: e.clientY - panY };
            });

            svg.addEventListener("mousemove", (e) => {
                if (!isPanning) return;
                panX = e.clientX - panStart.x;
                panY = e.clientY - panStart.y;
                updateTransform();
                updateMinimap();
            });

            svg.addEventListener("mouseup", () => { isPanning = false; });
            svg.addEventListener("mouseleave", () => { isPanning = false; });

            document.getElementById("reset-zoom-btn").addEventListener("click", resetZoom);
        }

        function updateTransform() {
            const viewport = document.getElementById("viewport");
            viewport.setAttribute("transform", `translate(${panX},${panY}) scale(${zoomScale})`);
        }

        function resetZoom() {
            zoomScale = 1;
            panX = 0;
            panY = 0;
            updateTransform();
            updateMinimap();
        }

        // --- Minimap ---
        function updateMinimap() {
            const minimap = document.getElementById("minimap");
            const mmContent = document.getElementById("minimap-content");
            const mmViewport = document.getElementById("minimap-viewport");

            while (mmContent.firstChild) mmContent.removeChild(mmContent.firstChild);

            const viewport = document.getElementById("viewport");
            const clone = viewport.cloneNode(true);
            clone.removeAttribute("transform");
            clone.setAttribute("transform", "scale(0.1)");
            mmContent.appendChild(clone);

            mmViewport.setAttribute("x", -panX * 0.1);
            mmViewport.setAttribute("y", -panY * 0.1);
            mmViewport.setAttribute("width", minimap.clientWidth * 0.1 / zoomScale);
            mmViewport.setAttribute("height", minimap.clientHeight * 0.1 / zoomScale);
        }

        // --- Search ---
        function enableSearch() {
            const box = document.getElementById("search-box");
            box.addEventListener("input", () => {
                const query = box.value.toLowerCase();
                const rects = document.querySelectorAll(".node rect");
                rects.forEach(r => r.classList.remove("highlight"));

                if (!query) return;

                const matches = [];
                document.querySelectorAll(".node").forEach(node => {
                    const label = (node.getAttribute("data-label") || "").toLowerCase();
                    if (label.includes(query)) {
                        const rect = node.querySelector("rect");
                        rect.classList.add("highlight");
                        matches.push(node);
                    }
                });

                if (matches.length > 0) {
                    const rect = matches[0].querySelector("rect");
                    const x = parseFloat(rect.getAttribute("x"));
                    const y = parseFloat(rect.getAttribute("y"));
                    panX = -x + 200;
                    panY = -y + 200;
                    updateTransform();
                    updateMinimap();
                }
            });
        }

        // --- Lane filters ---
        function enableLaneFilters() {
            const container = document.getElementById("lane-filters");
            container.innerHTML = "<strong>Show lanes:</strong>";

            lanes.forEach(lane => {
                const id = "lane-" + lane.replace(/\s+/g, "-");
                const label = document.createElement("label");
                label.innerHTML = `
                    <input type="checkbox" id="${id}" data-lane="${lane}" checked>
                    ${lane}
                `;
                container.appendChild(label);
            });

            container.querySelectorAll("input[type=checkbox]").forEach(cb => {
                cb.addEventListener("change", () => {
                    const lane = cb.getAttribute("data-lane");
                    activeLaneVisibility[lane] = cb.checked;
                    if (currentLevel === 1) renderLevel1();
                    else if (currentLevel === 2 && currentParentStep) renderLevel2(currentParentStep);
                });
            });
        }

        // --- Dark mode ---
        function enableDarkModeToggle() {
            const btn = document.getElementById("dark-toggle-btn");
            btn.addEventListener("click", () => {
                const root = document.documentElement;
                const isDark = root.classList.toggle("dark");
                btn.textContent = isDark ? "Light mode" : "Dark mode";
            });
        }

        // --- Init ---
        window.addEventListener("load", loadProcess);
    </script>
</body>

</html>